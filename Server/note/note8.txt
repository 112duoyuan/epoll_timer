IO处理单元、逻辑单元
Reactor模式
1）主线程往epoll内核事件表中注册socket上的读就绪事件。

2）主线程调用epoll_wait等待socket上有数据可读。

3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将
socket可读事件放入请求队列。

4）睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数
据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就
绪事件。

5）主线程调用epoll_wait等待socket可写。

6）当socket可写时，epoll_wait通知主线程。主线程将socket可写事
件放入请求队列。

7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服
务器处理客户请求的结果。

Proactor模式
1）主线程调用aio_read函数向内核注册socket上的读完成事件，并
告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序

2）主线程继续处理其他逻辑。

3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送
一个信号，以通知应用程序数据已经可用。

4）应用程序预先定义好的信号处理函数选择一个工作线程来处理
客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注
册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操
作完成时如何通知应用程序（仍然以信号为例）.

5）主线程继续处理其他逻辑。

6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送
一个信号，以通知应用程序数据已经发送完毕。

7）应用程序预先定义好的信号处理函数选择一个工作线程来做善
后处理，比如决定是否关闭socket。


chapt8 done!
